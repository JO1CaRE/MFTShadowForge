# MFTShadowForge

**MFTShadowForge** - консольный инструмент для цифровой криминалистики и реагирования на инциденты, который работает с NTFS Master File Table (MFT).
Он умеет:
- извлекать MFT с работающего диска (например, `C:`) в сырой (raw) файл;
- разбирать raw MFT и выгружать результаты в формат JSON Lines (один JSON-объект на строку);
- помечать записи по встроенным эвристикам (подозрительные временные метки, вероятное копирование, возможная неполная запись и другое);
- применять пользовательские правила (фильтры по пути) и ставить флаг `FitsRules` для совпадений.

Проект рассчитан на обработку больших таблиц MFT: формат JSONL позволяет писать вывод потоково и дальше быстро фильтровать его любыми утилитами или скриптами.

---

## Возможности

### 1) Извлечение MFT (extract)
- Открывает том напрямую (на Windows - через `\\.\C:`) или читает raw-образ как обычный файл.
- Читает загрузочный сектор NTFS, проверяет ключевые параметры (размер сектора, кластер, размер записи MFT).
- Находит размещение $MFT и извлекает его в raw-файл.
- Параллельно сохраняет метаданные тома в файл `<out>.meta.json` (они используются при последующем разборе).

Важно:
- Для чтения `\\.\C:` обычно нужны права администратора.
- Поддержка E01 в текущей реализации не добавлена (инструмент работает с тем, что доступно как обычный файл или как устройство тома).

### 2) Разбор MFT в JSONL (parse)
- Делает 2 прохода:
  - Проход 1 - строит дерево путей (родитель -> потомок) и вычисляет базовые ориентиры.
  - Проход 2 - парсит атрибуты и пишет итоговый JSONL.
- Восстанавливает полный путь (`Full_Path`) с учетом `SequenceNumber` (чтобы не строить ложные пути для перераспределенных записей).
- Учитывает extents из резидентного `$ATTRIBUTE_LIST` (если список атрибутов нерезидентный - ставит флаг `ComplexExtents`).
- Извлекает временные метки из:
  - `$STANDARD_INFORMATION` (0x10)
  - `$FILE_NAME` (0x30)
- Вычисляет признаки:
  - `Timestomped` - расхождение временных меток (в том числе "раньше рождения тома", если оно оценено)
  - `uSecZeros` - подозрительный рисунок нулевых долей секунды
  - `Copied` - эвристика "создан позже, чем изменен"
  - `TornWrite` - возможная неполная запись сектора (по механизму fixup)
- Отмечает ADS:
  - если встречается атрибут `$DATA` с именем потока, выставляет `HasADS`
  - если имя потока равно `Zone.Identifier`, сохраняет содержимое в `ZoneIdContents`
- Опционально извлекает содержимое резидентного `$DATA` (флаг `--data`) и кладет текст в `ContentData`.

### 3) Полный цикл (play)
Команда `play` запускает `extract`, затем `parse` и складывает результаты в указанную директорию.

---

## Сборка

Нужен Rust (edition 2021).

```bash
cargo build --release
```

Бинарный файл будет в `target/release/`. Имя файла зависит от того, как вы его назвали при сборке (в примерах ниже используется `MFTShadowForge.exe`).

---

## Использование

### Extract
Извлечь MFT с диска `C:` в raw-файл:

```bash
MFTShadowForge.exe extract --image C: --out C:\MftDump\mft.raw
# или коротко
MFTShadowForge.exe extract -i C: -o C:\MftDump\mft.raw
```

Рядом будет создан файл метаданных:
- `C:\MftDump\mft.raw.meta.json`

### Parse
Распарсить raw MFT в JSONL:

```bash
MFTShadowForge.exe parse --path C:\MftDump\mft.raw --out-json C:\MftDump\report.jsonl
# или коротко
MFTShadowForge.exe parse -p C:\MftDump\mft.raw -j C:\MftDump\report.jsonl
```

С извлечением резидентного `$DATA`:

```bash
MFTShadowForge.exe parse -p C:\MftDump\mft.raw -j C:\MftDump\report.jsonl --data
```

### Play
Полный цикл:

```bash
MFTShadowForge.exe play --image C: --out C:\MftDump --data
# или коротко
MFTShadowForge.exe play -i C: -o C:\MftDump -d
```

---

## Формат вывода (JSONL)

Вывод - это **JSON Lines**: каждый объект идет отдельной строкой. Это удобно для потоковой обработки.

Ключевые поля (не полный список):
- `EntryNumber`, `SequenceNumber` - номер записи и sequence number
- `InUse`, `IsDirectory` - признаки использования и каталога
- `ParentEntryNumber`, `ParentSequenceNumber` - родитель
- `Full_Path` - восстановленный полный путь
- `FileSize`, `Extension`
- Временные метки:
  - `Created0x10`, `LastModified0x10`, `LastRecordChange0x10`, `LastAccess0x10`
  - `Created0x30`, `LastModified0x30`, `LastRecordChange0x30`, `LastAccess0x30`
- Признаки:
  - `Timestomped`, `Copied`, `uSecZeros`, `TornWrite`, `ComplexExtents`
- ADS:
  - `HasADS`, `ZoneIdContents`
- Опционально:
  - `ContentData` (если включен `--data`)
- `SourceFile` - исходный raw MFT файл

Пример одной строки (сокращенный):

```json
{"EntryNumber":12345,"SequenceNumber":9,"InUse":true,"IsDirectory":false,"Full_Path":"C:\\Users\\Public\\test.exe","FileSize":53248,"Created0x10":"2026-01-12T12:34:56Z","Created0x30":"2026-01-12T12:34:56Z","Timestomped":false,"FitsRules":true,"HasADS":true,"ZoneIdContents":"[ZoneTransfer]\nZoneId=3\n","TornWrite":false}
```

---

## Правила (фильтрация по пути)

### Как работают правила
Правила используются для установки флага `FitsRules`.
Проверка идет по `Full_Path` в нижнем регистре, поэтому сопоставление фактически нечувствительно к регистру.

Правила задаются в исходном коде в файле:

- `src/commands/parse.rs` - переменная `rules_list: Vec<Rule>`

В текущей версии правила являются "встроенными" (чтобы изменить их - нужно поправить список и пересобрать проект).

### Доступные типы правил
В `src/rules/rules.rs` реализованы:

- `Rule::glob(pattern)` - сопоставление по шаблону `*` и `?`
  - `*` - любая последовательность символов
  - `?` - один любой символ
  - сопоставление идет по всей строке, поэтому для "содержит" обычно добавляют `*` слева и справа
- `Rule::starts_with("...")`
- `Rule::ends_with("...")`
- `Rule::contains("...")`
- логика:
  - `a.and(b)` - оба условия должны быть истинны
  - `a.not()` - отрицание

Важно:
- Оператора `OR` внутри одного выражения нет. Эквивалент `OR` делается списком: если совпало хотя бы одно правило из `rules_list`, то `FitsRules=true`.

### Примеры правил

1) Все `.exe` в публичных каталогах:

```rust
Rule::starts_with("C:\\Users\\Public\\").and(Rule::ends_with(".exe"))
```

2) Любые `.dll` в `system32`, но исключить конкретное имя:

```rust
Rule::contains("\\system32\\")
    .and(Rule::ends_with(".dll"))
    .and(Rule::ends_with("\\bad.dll").not())
```

3) Глоб-шаблон (обратите внимание на raw-строку `r"..."`, чтобы не экранировать `\`):

```rust
Rule::glob(r"*\$Recycle.Bin\*.exe").unwrap()
```

4) Несколько независимых правил (логика "или"):

```rust
let rules_list: Vec<Rule> = vec![
    Rule::glob(r"*\\Temp\\*.exe").unwrap(),
    Rule::glob(r"*\\AppData\\Roaming\\*.ps1").unwrap(),
    Rule::starts_with("C:\\Users\\Public\\").and(Rule::ends_with(".exe")),
];
```

---

## Ограничения текущей версии

- Извлечение MFT с тома `\\.\X:` актуально для Windows и требует прав администратора.
- Извлекается содержимое `$DATA` только для резидентных данных и только в текстовом виде (с фильтрацией управляющих символов).
- Extents обрабатываются для резидентного `$ATTRIBUTE_LIST`. Если `$ATTRIBUTE_LIST` нерезидентный, выставляется `ComplexExtents=true`.

---

## Идеи для развития

- Загрузка правил из внешнего файла (например, JSON или YAML), чтобы не пересобирать проект.
- Расширение логики правил (OR-группы, привязка правил к расширению, размеру, временным меткам).
- Выгрузка дополнительных атрибутов NTFS (например, `$OBJECT_ID`, `$REPARSE_POINT`).
- Режим "минимальный вывод" для ускорения и экономии места.

---

## Правовые и организационные ограничения

Инструмент предназначен для расследования инцидентов и анализа носителей в рамках законных полномочий.
Используйте его только на системах и образах, к которым у вас есть разрешенный доступ.
